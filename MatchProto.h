// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.7.
// **********************************************************************

#ifndef __MATCHPROTO_H_
#define __MATCHPROTO_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace match
{
    enum UserState
    {
        USER_STATE_DEFAULT = 0,
        USER_STATE_PLAYING_GAME = 1,
        USER_STATE_KNOCKOUT = 2,
    };
    inline string etos(const UserState & e)
    {
        switch(e)
        {
            case USER_STATE_DEFAULT: return "USER_STATE_DEFAULT";
            case USER_STATE_PLAYING_GAME: return "USER_STATE_PLAYING_GAME";
            case USER_STATE_KNOCKOUT: return "USER_STATE_KNOCKOUT";
            default: return "";
        }
    }
    inline int stoe(const string & s, UserState & e)
    {
        if(s == "USER_STATE_DEFAULT")  { e=USER_STATE_DEFAULT; return 0;}
        if(s == "USER_STATE_PLAYING_GAME")  { e=USER_STATE_PLAYING_GAME; return 0;}
        if(s == "USER_STATE_KNOCKOUT")  { e=USER_STATE_KNOCKOUT; return 0;}

        return -1;
    }

    enum MatchState
    {
        MATCH_STATE_DEFAULT = 0,
        MATCH_STATE_PLAYING_GAME = 1,
        MATCH_STATE_END = 2,
    };
    inline string etos(const MatchState & e)
    {
        switch(e)
        {
            case MATCH_STATE_DEFAULT: return "MATCH_STATE_DEFAULT";
            case MATCH_STATE_PLAYING_GAME: return "MATCH_STATE_PLAYING_GAME";
            case MATCH_STATE_END: return "MATCH_STATE_END";
            default: return "";
        }
    }
    inline int stoe(const string & s, MatchState & e)
    {
        if(s == "MATCH_STATE_DEFAULT")  { e=MATCH_STATE_DEFAULT; return 0;}
        if(s == "MATCH_STATE_PLAYING_GAME")  { e=MATCH_STATE_PLAYING_GAME; return 0;}
        if(s == "MATCH_STATE_END")  { e=MATCH_STATE_END; return 0;}

        return -1;
    }

    enum ConsumeType
    {
        CONSUME_TYPE_REPURCHASE = 0,
        CONSUME_TYPE_ADDITIONAL = 1,
    };
    inline string etos(const ConsumeType & e)
    {
        switch(e)
        {
            case CONSUME_TYPE_REPURCHASE: return "CONSUME_TYPE_REPURCHASE";
            case CONSUME_TYPE_ADDITIONAL: return "CONSUME_TYPE_ADDITIONAL";
            default: return "";
        }
    }
    inline int stoe(const string & s, ConsumeType & e)
    {
        if(s == "CONSUME_TYPE_REPURCHASE")  { e=CONSUME_TYPE_REPURCHASE; return 0;}
        if(s == "CONSUME_TYPE_ADDITIONAL")  { e=CONSUME_TYPE_ADDITIONAL; return 0;}

        return -1;
    }

    struct UserRankInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserRankInfo";
        }
        static string MD5()
        {
            return "f6f7a4bee39a0e5a31c7faf6fba02249";
        }
        UserRankInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            rank = 0;
            chip = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
            if (rank != 0)
            {
                _os.write(rank, 1);
            }
            if (chip != 0)
            {
                _os.write(chip, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
            _is.read(rank, 1, false);
            _is.read(chip, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["rank"] = tars::JsonOutput::writeJson(rank);
            p->value["chip"] = tars::JsonOutput::writeJson(chip);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(rank,pObj->value["rank"], false);
            tars::JsonInput::readJson(chip,pObj->value["chip"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(rank,"rank");
            _ds.display(chip,"chip");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(rank, true);
            _ds.displaySimple(chip, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int32 rank;
        tars::Int64 chip;
    };
    inline bool operator==(const UserRankInfo&l, const UserRankInfo&r)
    {
        return l.uid == r.uid && l.rank == r.rank && l.chip == r.chip;
    }
    inline bool operator!=(const UserRankInfo&l, const UserRankInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserRankInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserRankInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserMatchInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserMatchInfo";
        }
        static string MD5()
        {
            return "fbee022731165ab25225e7be143eeed2";
        }
        UserMatchInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            chip = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
            if (chip != 0)
            {
                _os.write(chip, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
            _is.read(chip, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["chip"] = tars::JsonOutput::writeJson(chip);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(chip,pObj->value["chip"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(chip,"chip");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(chip, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int64 chip;
    };
    inline bool operator==(const UserMatchInfo&l, const UserMatchInfo&r)
    {
        return l.uid == r.uid && l.chip == r.chip;
    }
    inline bool operator!=(const UserMatchInfo&l, const UserMatchInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserMatchInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserMatchInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportUserGameInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportUserGameInfoReq";
        }
        static string MD5()
        {
            return "5176cc4a7f40dba982082fba34ba6d85";
        }
        ReportUserGameInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (userInfo.size() > 0)
            {
                _os.write(userInfo, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(userInfo, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["userInfo"] = tars::JsonOutput::writeJson(userInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(userInfo,pObj->value["userInfo"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(userInfo,"userInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(userInfo, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        map<tars::Int64, match::UserMatchInfo> userInfo;
    };
    inline bool operator==(const ReportUserGameInfoReq&l, const ReportUserGameInfoReq&r)
    {
        return l.matchID == r.matchID && l.userInfo == r.userInfo;
    }
    inline bool operator!=(const ReportUserGameInfoReq&l, const ReportUserGameInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportUserGameInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportUserGameInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportUserGameInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportUserGameInfoResp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        ReportUserGameInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
    };
    inline bool operator==(const ReportUserGameInfoResp&l, const ReportUserGameInfoResp&r)
    {
        return l.resultCode == r.resultCode;
    }
    inline bool operator!=(const ReportUserGameInfoResp&l, const ReportUserGameInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportUserGameInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportUserGameInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportUserKnockoutInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportUserKnockoutInfoReq";
        }
        static string MD5()
        {
            return "eccfb423bba17e69a05dd15dcbfec4c0";
        }
        ReportUserKnockoutInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (vecUin.size() > 0)
            {
                _os.write(vecUin, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(vecUin, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["vecUin"] = tars::JsonOutput::writeJson(vecUin);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(vecUin,pObj->value["vecUin"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(vecUin,"vecUin");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(vecUin, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        vector<tars::Int64> vecUin;
    };
    inline bool operator==(const ReportUserKnockoutInfoReq&l, const ReportUserKnockoutInfoReq&r)
    {
        return l.matchID == r.matchID && l.vecUin == r.vecUin;
    }
    inline bool operator!=(const ReportUserKnockoutInfoReq&l, const ReportUserKnockoutInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportUserKnockoutInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportUserKnockoutInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportUserKnockoutInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportUserKnockoutInfoResp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        ReportUserKnockoutInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
    };
    inline bool operator==(const ReportUserKnockoutInfoResp&l, const ReportUserKnockoutInfoResp&r)
    {
        return l.resultCode == r.resultCode;
    }
    inline bool operator!=(const ReportUserKnockoutInfoResp&l, const ReportUserKnockoutInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportUserKnockoutInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportUserKnockoutInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportUserStateReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportUserStateReq";
        }
        static string MD5()
        {
            return "7157f6e8688ecfdc13b66f7f6d9e56b4";
        }
        ReportUserStateReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (mapState.size() > 0)
            {
                _os.write(mapState, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(mapState, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["mapState"] = tars::JsonOutput::writeJson(mapState);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(mapState,pObj->value["mapState"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(mapState,"mapState");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(mapState, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        map<tars::Int64, match::UserState> mapState;
    };
    inline bool operator==(const ReportUserStateReq&l, const ReportUserStateReq&r)
    {
        return l.matchID == r.matchID && l.mapState == r.mapState;
    }
    inline bool operator!=(const ReportUserStateReq&l, const ReportUserStateReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportUserStateReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportUserStateReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportUserStateResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportUserStateResp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        ReportUserStateResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
    };
    inline bool operator==(const ReportUserStateResp&l, const ReportUserStateResp&r)
    {
        return l.resultCode == r.resultCode;
    }
    inline bool operator!=(const ReportUserStateResp&l, const ReportUserStateResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportUserStateResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportUserStateResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MatchInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.MatchInfo";
        }
        static string MD5()
        {
            return "70fcff39b83cd811740b931878010a9b";
        }
        MatchInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            startTime = 0;
            count = 0;
            remainingCount = 0;
            avgChip = 0;
            remainingTime = 0;
            blindLevel = 0;
            maxBlindLevel = 0;
            startTimeType = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (startTime != 0)
            {
                _os.write(startTime, 0);
            }
            if (count != 0)
            {
                _os.write(count, 1);
            }
            if (remainingCount != 0)
            {
                _os.write(remainingCount, 2);
            }
            if (avgChip != 0)
            {
                _os.write(avgChip, 3);
            }
            if (remainingTime != 0)
            {
                _os.write(remainingTime, 4);
            }
            if (blindLevel != 0)
            {
                _os.write(blindLevel, 5);
            }
            if (maxBlindLevel != 0)
            {
                _os.write(maxBlindLevel, 6);
            }
            _os.write((tars::Int32)matchState, 7);
            if (startTimeType != 0)
            {
                _os.write(startTimeType, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(startTime, 0, false);
            _is.read(count, 1, false);
            _is.read(remainingCount, 2, false);
            _is.read(avgChip, 3, false);
            _is.read(remainingTime, 4, false);
            _is.read(blindLevel, 5, false);
            _is.read(maxBlindLevel, 6, false);
            tars::Int32 eTemp7 = match::MATCH_STATE_DEFAULT;
            _is.read(eTemp7, 7, false);
            matchState = (match::MatchState)eTemp7;
            _is.read(startTimeType, 8, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["startTime"] = tars::JsonOutput::writeJson(startTime);
            p->value["count"] = tars::JsonOutput::writeJson(count);
            p->value["remainingCount"] = tars::JsonOutput::writeJson(remainingCount);
            p->value["avgChip"] = tars::JsonOutput::writeJson(avgChip);
            p->value["remainingTime"] = tars::JsonOutput::writeJson(remainingTime);
            p->value["blindLevel"] = tars::JsonOutput::writeJson(blindLevel);
            p->value["maxBlindLevel"] = tars::JsonOutput::writeJson(maxBlindLevel);
            p->value["matchState"] = tars::JsonOutput::writeJson((tars::Int32)matchState);
            p->value["startTimeType"] = tars::JsonOutput::writeJson(startTimeType);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(startTime,pObj->value["startTime"], false);
            tars::JsonInput::readJson(count,pObj->value["count"], false);
            tars::JsonInput::readJson(remainingCount,pObj->value["remainingCount"], false);
            tars::JsonInput::readJson(avgChip,pObj->value["avgChip"], false);
            tars::JsonInput::readJson(remainingTime,pObj->value["remainingTime"], false);
            tars::JsonInput::readJson(blindLevel,pObj->value["blindLevel"], false);
            tars::JsonInput::readJson(maxBlindLevel,pObj->value["maxBlindLevel"], false);
            tars::JsonInput::readJson(matchState,pObj->value["matchState"], false);
            tars::JsonInput::readJson(startTimeType,pObj->value["startTimeType"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(startTime,"startTime");
            _ds.display(count,"count");
            _ds.display(remainingCount,"remainingCount");
            _ds.display(avgChip,"avgChip");
            _ds.display(remainingTime,"remainingTime");
            _ds.display(blindLevel,"blindLevel");
            _ds.display(maxBlindLevel,"maxBlindLevel");
            _ds.display((tars::Int32)matchState,"matchState");
            _ds.display(startTimeType,"startTimeType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(startTime, true);
            _ds.displaySimple(count, true);
            _ds.displaySimple(remainingCount, true);
            _ds.displaySimple(avgChip, true);
            _ds.displaySimple(remainingTime, true);
            _ds.displaySimple(blindLevel, true);
            _ds.displaySimple(maxBlindLevel, true);
            _ds.displaySimple((tars::Int32)matchState, true);
            _ds.displaySimple(startTimeType, false);
            return _os;
        }
    public:
        tars::Int32 startTime;
        tars::Int32 count;
        tars::Int32 remainingCount;
        tars::Int64 avgChip;
        tars::Int32 remainingTime;
        tars::Int32 blindLevel;
        tars::Int32 maxBlindLevel;
        match::MatchState matchState;
        tars::Int32 startTimeType;
    };
    inline bool operator==(const MatchInfo&l, const MatchInfo&r)
    {
        return l.startTime == r.startTime && l.count == r.count && l.remainingCount == r.remainingCount && l.avgChip == r.avgChip && l.remainingTime == r.remainingTime && l.blindLevel == r.blindLevel && l.maxBlindLevel == r.maxBlindLevel && l.matchState == r.matchState && l.startTimeType == r.startTimeType;
    }
    inline bool operator!=(const MatchInfo&l, const MatchInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MatchInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MatchInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportMatchInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportMatchInfoReq";
        }
        static string MD5()
        {
            return "5c2e35d58ba77190d7125786132d263f";
        }
        ReportMatchInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (data.size() > 0)
            {
                _os.write(data, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(data, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["data"] = tars::JsonOutput::writeJson(data);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(data,pObj->value["data"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        map<tars::Int32, match::MatchInfo> data;
    };
    inline bool operator==(const ReportMatchInfoReq&l, const ReportMatchInfoReq&r)
    {
        return l.data == r.data;
    }
    inline bool operator!=(const ReportMatchInfoReq&l, const ReportMatchInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportMatchInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportMatchInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ReportMatchInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ReportMatchInfoResp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        ReportMatchInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
    };
    inline bool operator==(const ReportMatchInfoResp&l, const ReportMatchInfoResp&r)
    {
        return l.resultCode == r.resultCode;
    }
    inline bool operator!=(const ReportMatchInfoResp&l, const ReportMatchInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ReportMatchInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ReportMatchInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserEntryFee : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserEntryFee";
        }
        static string MD5()
        {
            return "65337519ddfacda8757dc7b62e4a3c6d";
        }
        UserEntryFee()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            propsID = 0;
            number = 0;
            serviceFee = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (propsID != 0)
            {
                _os.write(propsID, 0);
            }
            if (number != 0)
            {
                _os.write(number, 1);
            }
            if (serviceFee != 0)
            {
                _os.write(serviceFee, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(propsID, 0, false);
            _is.read(number, 1, false);
            _is.read(serviceFee, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["propsID"] = tars::JsonOutput::writeJson(propsID);
            p->value["number"] = tars::JsonOutput::writeJson(number);
            p->value["serviceFee"] = tars::JsonOutput::writeJson(serviceFee);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(propsID,pObj->value["propsID"], false);
            tars::JsonInput::readJson(number,pObj->value["number"], false);
            tars::JsonInput::readJson(serviceFee,pObj->value["serviceFee"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(propsID,"propsID");
            _ds.display(number,"number");
            _ds.display(serviceFee,"serviceFee");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(propsID, true);
            _ds.displaySimple(number, true);
            _ds.displaySimple(serviceFee, false);
            return _os;
        }
    public:
        tars::Int32 propsID;
        tars::Int64 number;
        tars::Int64 serviceFee;
    };
    inline bool operator==(const UserEntryFee&l, const UserEntryFee&r)
    {
        return l.propsID == r.propsID && l.number == r.number && l.serviceFee == r.serviceFee;
    }
    inline bool operator!=(const UserEntryFee&l, const UserEntryFee&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserEntryFee&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserEntryFee&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SignUpInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.SignUpInfo";
        }
        static string MD5()
        {
            return "e91a8218f004067f0ab19bb68959d439";
        }
        SignUpInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
            chip = 0;
            ranking = 0;
            additional = 0;
            repurchase = 0;
            showtype = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (chip != 0)
            {
                _os.write(chip, 1);
            }
            if (ranking != 0)
            {
                _os.write(ranking, 2);
            }
            if (additional != 0)
            {
                _os.write(additional, 3);
            }
            if (repurchase != 0)
            {
                _os.write(repurchase, 4);
            }
            _os.write(userEntryFee, 5);
            _os.write((tars::Int32)userState, 6);
            if (showtype != 0)
            {
                _os.write(showtype, 7);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(chip, 1, false);
            _is.read(ranking, 2, false);
            _is.read(additional, 3, false);
            _is.read(repurchase, 4, false);
            _is.read(userEntryFee, 5, false);
            tars::Int32 eTemp6 = match::USER_STATE_DEFAULT;
            _is.read(eTemp6, 6, false);
            userState = (match::UserState)eTemp6;
            _is.read(showtype, 7, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["chip"] = tars::JsonOutput::writeJson(chip);
            p->value["ranking"] = tars::JsonOutput::writeJson(ranking);
            p->value["additional"] = tars::JsonOutput::writeJson(additional);
            p->value["repurchase"] = tars::JsonOutput::writeJson(repurchase);
            p->value["userEntryFee"] = tars::JsonOutput::writeJson(userEntryFee);
            p->value["userState"] = tars::JsonOutput::writeJson((tars::Int32)userState);
            p->value["showtype"] = tars::JsonOutput::writeJson(showtype);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(chip,pObj->value["chip"], false);
            tars::JsonInput::readJson(ranking,pObj->value["ranking"], false);
            tars::JsonInput::readJson(additional,pObj->value["additional"], false);
            tars::JsonInput::readJson(repurchase,pObj->value["repurchase"], false);
            tars::JsonInput::readJson(userEntryFee,pObj->value["userEntryFee"], false);
            tars::JsonInput::readJson(userState,pObj->value["userState"], false);
            tars::JsonInput::readJson(showtype,pObj->value["showtype"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(chip,"chip");
            _ds.display(ranking,"ranking");
            _ds.display(additional,"additional");
            _ds.display(repurchase,"repurchase");
            _ds.display(userEntryFee,"userEntryFee");
            _ds.display((tars::Int32)userState,"userState");
            _ds.display(showtype,"showtype");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(chip, true);
            _ds.displaySimple(ranking, true);
            _ds.displaySimple(additional, true);
            _ds.displaySimple(repurchase, true);
            _ds.displaySimple(userEntryFee, true);
            _ds.displaySimple((tars::Int32)userState, true);
            _ds.displaySimple(showtype, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        tars::Int64 chip;
        tars::Int32 ranking;
        tars::Int32 additional;
        tars::Int32 repurchase;
        match::UserEntryFee userEntryFee;
        match::UserState userState;
        tars::Int32 showtype;
    };
    inline bool operator==(const SignUpInfo&l, const SignUpInfo&r)
    {
        return l.matchID == r.matchID && l.chip == r.chip && l.ranking == r.ranking && l.additional == r.additional && l.repurchase == r.repurchase && l.userEntryFee == r.userEntryFee && l.userState == r.userState && l.showtype == r.showtype;
    }
    inline bool operator!=(const SignUpInfo&l, const SignUpInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SignUpInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SignUpInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserSignUpInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserSignUpInfo";
        }
        static string MD5()
        {
            return "119971a02c51b7a52210f46bedfc64fd";
        }
        UserSignUpInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (data.size() > 0)
            {
                _os.write(data, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(data, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["data"] = tars::JsonOutput::writeJson(data);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(data,pObj->value["data"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        map<tars::Int32, match::SignUpInfo> data;
    };
    inline bool operator==(const UserSignUpInfo&l, const UserSignUpInfo&r)
    {
        return l.data == r.data;
    }
    inline bool operator!=(const UserSignUpInfo&l, const UserSignUpInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserSignUpInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserSignUpInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserSignUpInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserSignUpInfoReq";
        }
        static string MD5()
        {
            return "5e2ee7cf80a6d6d2fba6a0a2f6718006";
        }
        UserSignUpInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            matchID = 0;
            showtype = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
            if (matchID != 0)
            {
                _os.write(matchID, 1);
            }
            if (showtype != 0)
            {
                _os.write(showtype, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
            _is.read(matchID, 1, false);
            _is.read(showtype, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["showtype"] = tars::JsonOutput::writeJson(showtype);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(showtype,pObj->value["showtype"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(matchID,"matchID");
            _ds.display(showtype,"showtype");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(showtype, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int32 matchID;
        tars::Int32 showtype;
    };
    inline bool operator==(const UserSignUpInfoReq&l, const UserSignUpInfoReq&r)
    {
        return l.uid == r.uid && l.matchID == r.matchID && l.showtype == r.showtype;
    }
    inline bool operator!=(const UserSignUpInfoReq&l, const UserSignUpInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserSignUpInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserSignUpInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserSignUpInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserSignUpInfoResp";
        }
        static string MD5()
        {
            return "e99fb39cd84dad62eb21fd1f74ed79c8";
        }
        UserSignUpInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            _os.write(info, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(info, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["info"] = tars::JsonOutput::writeJson(info);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(info,pObj->value["info"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(info,"info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(info, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        match::SignUpInfo info;
    };
    inline bool operator==(const UserSignUpInfoResp&l, const UserSignUpInfoResp&r)
    {
        return l.resultCode == r.resultCode && l.info == r.info;
    }
    inline bool operator!=(const UserSignUpInfoResp&l, const UserSignUpInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserSignUpInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserSignUpInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserAllSignUpInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserAllSignUpInfoReq";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        UserAllSignUpInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, false);
            return _os;
        }
    public:
        tars::Int64 uid;
    };
    inline bool operator==(const UserAllSignUpInfoReq&l, const UserAllSignUpInfoReq&r)
    {
        return l.uid == r.uid;
    }
    inline bool operator!=(const UserAllSignUpInfoReq&l, const UserAllSignUpInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserAllSignUpInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserAllSignUpInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserAllSignUpInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserAllSignUpInfoResp";
        }
        static string MD5()
        {
            return "bc1cf8efe1ceffdc13a2db3dfb1bf8fa";
        }
        UserAllSignUpInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            _os.write(info, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(info, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["info"] = tars::JsonOutput::writeJson(info);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(info,pObj->value["info"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(info,"info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(info, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        match::UserSignUpInfo info;
    };
    inline bool operator==(const UserAllSignUpInfoResp&l, const UserAllSignUpInfoResp&r)
    {
        return l.resultCode == r.resultCode && l.info == r.info;
    }
    inline bool operator!=(const UserAllSignUpInfoResp&l, const UserAllSignUpInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserAllSignUpInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserAllSignUpInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ConsumeBuyResReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ConsumeBuyResReq";
        }
        static string MD5()
        {
            return "650b8eeb5a6e8607e10e67aadc68255d";
        }
        ConsumeBuyResReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            matchID = 0;
            add = true;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
            if (matchID != 0)
            {
                _os.write(matchID, 1);
            }
            _os.write((tars::Int32)consumeType, 2);
            if (add != true)
            {
                _os.write(add, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
            _is.read(matchID, 1, false);
            tars::Int32 eTemp2 = match::CONSUME_TYPE_REPURCHASE;
            _is.read(eTemp2, 2, false);
            consumeType = (match::ConsumeType)eTemp2;
            _is.read(add, 3, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["consumeType"] = tars::JsonOutput::writeJson((tars::Int32)consumeType);
            p->value["add"] = tars::JsonOutput::writeJson(add);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(consumeType,pObj->value["consumeType"], false);
            tars::JsonInput::readJson(add,pObj->value["add"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(matchID,"matchID");
            _ds.display((tars::Int32)consumeType,"consumeType");
            _ds.display(add,"add");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple((tars::Int32)consumeType, true);
            _ds.displaySimple(add, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int32 matchID;
        match::ConsumeType consumeType;
        tars::Bool add;
    };
    inline bool operator==(const ConsumeBuyResReq&l, const ConsumeBuyResReq&r)
    {
        return l.uid == r.uid && l.matchID == r.matchID && l.consumeType == r.consumeType && l.add == r.add;
    }
    inline bool operator!=(const ConsumeBuyResReq&l, const ConsumeBuyResReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ConsumeBuyResReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ConsumeBuyResReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ConsumeBuyResResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.ConsumeBuyResResp";
        }
        static string MD5()
        {
            return "1b88c010f01ae6f33886b29fe7b56086";
        }
        ConsumeBuyResResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
            left = 0;
            add = true;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            if (left != 0)
            {
                _os.write(left, 1);
            }
            if (add != true)
            {
                _os.write(add, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(left, 1, false);
            _is.read(add, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["left"] = tars::JsonOutput::writeJson(left);
            p->value["add"] = tars::JsonOutput::writeJson(add);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(left,pObj->value["left"], false);
            tars::JsonInput::readJson(add,pObj->value["add"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(left,"left");
            _ds.display(add,"add");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(left, true);
            _ds.displaySimple(add, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        tars::Int32 left;
        tars::Bool add;
    };
    inline bool operator==(const ConsumeBuyResResp&l, const ConsumeBuyResResp&r)
    {
        return l.resultCode == r.resultCode && l.left == r.left && l.add == r.add;
    }
    inline bool operator!=(const ConsumeBuyResResp&l, const ConsumeBuyResResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ConsumeBuyResResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ConsumeBuyResResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MatchInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.MatchInfoReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        MatchInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
    };
    inline bool operator==(const MatchInfoReq&l, const MatchInfoReq&r)
    {
        return l.matchID == r.matchID;
    }
    inline bool operator!=(const MatchInfoReq&l, const MatchInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MatchInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MatchInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MatchInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.MatchInfoResp";
        }
        static string MD5()
        {
            return "7c3a5960c49b8844a06f2354640eb8be";
        }
        MatchInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            if (data.size() > 0)
            {
                _os.write(data, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(data, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["data"] = tars::JsonOutput::writeJson(data);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(data,pObj->value["data"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        map<tars::Int32, match::MatchInfo> data;
    };
    inline bool operator==(const MatchInfoResp&l, const MatchInfoResp&r)
    {
        return l.resultCode == r.resultCode && l.data == r.data;
    }
    inline bool operator!=(const MatchInfoResp&l, const MatchInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MatchInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MatchInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MatchUserInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.MatchUserInfoReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        MatchUserInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
    };
    inline bool operator==(const MatchUserInfoReq&l, const MatchUserInfoReq&r)
    {
        return l.matchID == r.matchID;
    }
    inline bool operator!=(const MatchUserInfoReq&l, const MatchUserInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MatchUserInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MatchUserInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MatchUserInfoResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.MatchUserInfoResp";
        }
        static string MD5()
        {
            return "eccfb423bba17e69a05dd15dcbfec4c0";
        }
        MatchUserInfoResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            if (vecUid.size() > 0)
            {
                _os.write(vecUid, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(vecUid, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["vecUid"] = tars::JsonOutput::writeJson(vecUid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(vecUid,pObj->value["vecUid"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(vecUid,"vecUid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(vecUid, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        vector<tars::Int64> vecUid;
    };
    inline bool operator==(const MatchUserInfoResp&l, const MatchUserInfoResp&r)
    {
        return l.resultCode == r.resultCode && l.vecUid == r.vecUid;
    }
    inline bool operator!=(const MatchUserInfoResp&l, const MatchUserInfoResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MatchUserInfoResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MatchUserInfoResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CancelMatchReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.CancelMatchReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        CancelMatchReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
    };
    inline bool operator==(const CancelMatchReq&l, const CancelMatchReq&r)
    {
        return l.matchID == r.matchID;
    }
    inline bool operator!=(const CancelMatchReq&l, const CancelMatchReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CancelMatchReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CancelMatchReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CancelMatchResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.CancelMatchResp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        CancelMatchResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
    };
    inline bool operator==(const CancelMatchResp&l, const CancelMatchResp&r)
    {
        return l.resultCode == r.resultCode;
    }
    inline bool operator!=(const CancelMatchResp&l, const CancelMatchResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CancelMatchResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CancelMatchResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CleanMatchReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.CleanMatchReq";
        }
        static string MD5()
        {
            return "3fbec5b42399a41c9a18269ae4789a8c";
        }
        CleanMatchReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
            bSng = true;
            Uid = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (bSng != true)
            {
                _os.write(bSng, 1);
            }
            if (Uid != 0)
            {
                _os.write(Uid, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(bSng, 1, false);
            _is.read(Uid, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["bSng"] = tars::JsonOutput::writeJson(bSng);
            p->value["Uid"] = tars::JsonOutput::writeJson(Uid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(bSng,pObj->value["bSng"], false);
            tars::JsonInput::readJson(Uid,pObj->value["Uid"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(bSng,"bSng");
            _ds.display(Uid,"Uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(bSng, true);
            _ds.displaySimple(Uid, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        tars::Bool bSng;
        tars::Int64 Uid;
    };
    inline bool operator==(const CleanMatchReq&l, const CleanMatchReq&r)
    {
        return l.matchID == r.matchID && l.bSng == r.bSng && l.Uid == r.Uid;
    }
    inline bool operator!=(const CleanMatchReq&l, const CleanMatchReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CleanMatchReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CleanMatchReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CleanMatchResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.CleanMatchResp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        CleanMatchResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
    };
    inline bool operator==(const CleanMatchResp&l, const CleanMatchResp&r)
    {
        return l.resultCode == r.resultCode;
    }
    inline bool operator!=(const CleanMatchResp&l, const CleanMatchResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CleanMatchResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CleanMatchResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RewardGoods : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.RewardGoods";
        }
        static string MD5()
        {
            return "60ffe44f33f21e42077330b6f89ce219";
        }
        RewardGoods()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            propsID = 0;
            number = 0;
            type = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (propsID != 0)
            {
                _os.write(propsID, 1);
            }
            if (number != 0)
            {
                _os.write(number, 2);
            }
            if (type != 0)
            {
                _os.write(type, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(propsID, 1, false);
            _is.read(number, 2, false);
            _is.read(type, 3, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["propsID"] = tars::JsonOutput::writeJson(propsID);
            p->value["number"] = tars::JsonOutput::writeJson(number);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(propsID,pObj->value["propsID"], false);
            tars::JsonInput::readJson(number,pObj->value["number"], false);
            tars::JsonInput::readJson(type,pObj->value["type"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(propsID,"propsID");
            _ds.display(number,"number");
            _ds.display(type,"type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(propsID, true);
            _ds.displaySimple(number, true);
            _ds.displaySimple(type, false);
            return _os;
        }
    public:
        tars::Int32 propsID;
        tars::Int64 number;
        tars::Int32 type;
    };
    inline bool operator==(const RewardGoods&l, const RewardGoods&r)
    {
        return l.propsID == r.propsID && l.number == r.number && l.type == r.type;
    }
    inline bool operator!=(const RewardGoods&l, const RewardGoods&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RewardGoods&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RewardGoods&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RewardReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.RewardReq";
        }
        static string MD5()
        {
            return "533547304daf72978954337a74acd0b0";
        }
        RewardReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
            isSng = true;
            iRank = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (vecUid.size() > 0)
            {
                _os.write(vecUid, 1);
            }
            if (items.size() > 0)
            {
                _os.write(items, 2);
            }
            if (isSng != true)
            {
                _os.write(isSng, 3);
            }
            if (iRank != 0)
            {
                _os.write(iRank, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(vecUid, 1, false);
            _is.read(items, 2, false);
            _is.read(isSng, 3, false);
            _is.read(iRank, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["vecUid"] = tars::JsonOutput::writeJson(vecUid);
            p->value["items"] = tars::JsonOutput::writeJson(items);
            p->value["isSng"] = tars::JsonOutput::writeJson(isSng);
            p->value["iRank"] = tars::JsonOutput::writeJson(iRank);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(vecUid,pObj->value["vecUid"], false);
            tars::JsonInput::readJson(items,pObj->value["items"], false);
            tars::JsonInput::readJson(isSng,pObj->value["isSng"], false);
            tars::JsonInput::readJson(iRank,pObj->value["iRank"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(vecUid,"vecUid");
            _ds.display(items,"items");
            _ds.display(isSng,"isSng");
            _ds.display(iRank,"iRank");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(vecUid, true);
            _ds.displaySimple(items, true);
            _ds.displaySimple(isSng, true);
            _ds.displaySimple(iRank, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        vector<tars::Int64> vecUid;
        vector<match::RewardGoods> items;
        tars::Bool isSng;
        tars::Int32 iRank;
    };
    inline bool operator==(const RewardReq&l, const RewardReq&r)
    {
        return l.matchID == r.matchID && l.vecUid == r.vecUid && l.items == r.items && l.isSng == r.isSng && l.iRank == r.iRank;
    }
    inline bool operator!=(const RewardReq&l, const RewardReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RewardReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RewardReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserRewardGoods : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.UserRewardGoods";
        }
        static string MD5()
        {
            return "cda235cae6a4347ad0d7b5e5750a2212";
        }
        UserRewardGoods()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            total = 0;
            ratio = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
            if (total != 0)
            {
                _os.write(total, 1);
            }
            if (ratio != 0)
            {
                _os.write(ratio, 2);
            }
            if (goods.size() > 0)
            {
                _os.write(goods, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
            _is.read(total, 1, false);
            _is.read(ratio, 2, false);
            _is.read(goods, 3, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["total"] = tars::JsonOutput::writeJson(total);
            p->value["ratio"] = tars::JsonOutput::writeJson(ratio);
            p->value["goods"] = tars::JsonOutput::writeJson(goods);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(total,pObj->value["total"], false);
            tars::JsonInput::readJson(ratio,pObj->value["ratio"], false);
            tars::JsonInput::readJson(goods,pObj->value["goods"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(total,"total");
            _ds.display(ratio,"ratio");
            _ds.display(goods,"goods");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(total, true);
            _ds.displaySimple(ratio, true);
            _ds.displaySimple(goods, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int64 total;
        tars::Int32 ratio;
        vector<match::RewardGoods> goods;
    };
    inline bool operator==(const UserRewardGoods&l, const UserRewardGoods&r)
    {
        return l.uid == r.uid && l.total == r.total && l.ratio == r.ratio && l.goods == r.goods;
    }
    inline bool operator!=(const UserRewardGoods&l, const UserRewardGoods&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserRewardGoods&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserRewardGoods&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RewardResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.RewardResp";
        }
        static string MD5()
        {
            return "9d34f7c2a0e708646e014d491b2c020a";
        }
        RewardResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            if (data.size() > 0)
            {
                _os.write(data, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(data, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["data"] = tars::JsonOutput::writeJson(data);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(data,pObj->value["data"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        map<tars::Int64, match::UserRewardGoods> data;
    };
    inline bool operator==(const RewardResp&l, const RewardResp&r)
    {
        return l.resultCode == r.resultCode && l.data == r.data;
    }
    inline bool operator!=(const RewardResp&l, const RewardResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RewardResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RewardResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SignUpReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.SignUpReq";
        }
        static string MD5()
        {
            return "4c440c468038da5c650fc49b37047834";
        }
        SignUpReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            matchID = 0;
            delay = true;
            isSng = true;
            tableID = 0;
            isRobot = true;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
            if (matchID != 0)
            {
                _os.write(matchID, 1);
            }
            if (delay != true)
            {
                _os.write(delay, 2);
            }
            if (isSng != true)
            {
                _os.write(isSng, 3);
            }
            if (tableID != 0)
            {
                _os.write(tableID, 4);
            }
            if (isRobot != true)
            {
                _os.write(isRobot, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false);
            _is.read(matchID, 1, false);
            _is.read(delay, 2, false);
            _is.read(isSng, 3, false);
            _is.read(tableID, 4, false);
            _is.read(isRobot, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["delay"] = tars::JsonOutput::writeJson(delay);
            p->value["isSng"] = tars::JsonOutput::writeJson(isSng);
            p->value["tableID"] = tars::JsonOutput::writeJson(tableID);
            p->value["isRobot"] = tars::JsonOutput::writeJson(isRobot);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(delay,pObj->value["delay"], false);
            tars::JsonInput::readJson(isSng,pObj->value["isSng"], false);
            tars::JsonInput::readJson(tableID,pObj->value["tableID"], false);
            tars::JsonInput::readJson(isRobot,pObj->value["isRobot"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(matchID,"matchID");
            _ds.display(delay,"delay");
            _ds.display(isSng,"isSng");
            _ds.display(tableID,"tableID");
            _ds.display(isRobot,"isRobot");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(delay, true);
            _ds.displaySimple(isSng, true);
            _ds.displaySimple(tableID, true);
            _ds.displaySimple(isRobot, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int32 matchID;
        tars::Bool delay;
        tars::Bool isSng;
        tars::Int32 tableID;
        tars::Bool isRobot;
    };
    inline bool operator==(const SignUpReq&l, const SignUpReq&r)
    {
        return l.uid == r.uid && l.matchID == r.matchID && l.delay == r.delay && l.isSng == r.isSng && l.tableID == r.tableID && l.isRobot == r.isRobot;
    }
    inline bool operator!=(const SignUpReq&l, const SignUpReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SignUpReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SignUpReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SignUpResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.SignUpResp";
        }
        static string MD5()
        {
            return "ffc2604c06f8457973fadb5461f6c3c6";
        }
        SignUpResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
            delay = true;
            roomID = "";
            matchID = "";
            tableID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            _os.write(entryFee, 1);
            if (delay != true)
            {
                _os.write(delay, 2);
            }
            if (roomID != "")
            {
                _os.write(roomID, 3);
            }
            if (matchID != "")
            {
                _os.write(matchID, 4);
            }
            if (tableID != 0)
            {
                _os.write(tableID, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(entryFee, 1, false);
            _is.read(delay, 2, false);
            _is.read(roomID, 3, false);
            _is.read(matchID, 4, false);
            _is.read(tableID, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["entryFee"] = tars::JsonOutput::writeJson(entryFee);
            p->value["delay"] = tars::JsonOutput::writeJson(delay);
            p->value["roomID"] = tars::JsonOutput::writeJson(roomID);
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["tableID"] = tars::JsonOutput::writeJson(tableID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(entryFee,pObj->value["entryFee"], false);
            tars::JsonInput::readJson(delay,pObj->value["delay"], false);
            tars::JsonInput::readJson(roomID,pObj->value["roomID"], false);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(tableID,pObj->value["tableID"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(entryFee,"entryFee");
            _ds.display(delay,"delay");
            _ds.display(roomID,"roomID");
            _ds.display(matchID,"matchID");
            _ds.display(tableID,"tableID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(entryFee, true);
            _ds.displaySimple(delay, true);
            _ds.displaySimple(roomID, true);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(tableID, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        match::UserEntryFee entryFee;
        tars::Bool delay;
        std::string roomID;
        std::string matchID;
        tars::Int32 tableID;
    };
    inline bool operator==(const SignUpResp&l, const SignUpResp&r)
    {
        return l.resultCode == r.resultCode && l.entryFee == r.entryFee && l.delay == r.delay && l.roomID == r.roomID && l.matchID == r.matchID && l.tableID == r.tableID;
    }
    inline bool operator!=(const SignUpResp&l, const SignUpResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SignUpResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SignUpResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct QuitReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.QuitReq";
        }
        static string MD5()
        {
            return "c707f12b8d04086b8369afaf89a36d55";
        }
        QuitReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            matchID = 0;
            uid = 0;
            drawback = true;
            isSng = true;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (matchID != 0)
            {
                _os.write(matchID, 0);
            }
            if (uid != 0)
            {
                _os.write(uid, 1);
            }
            if (drawback != true)
            {
                _os.write(drawback, 2);
            }
            if (isSng != true)
            {
                _os.write(isSng, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(matchID, 0, false);
            _is.read(uid, 1, false);
            _is.read(drawback, 2, false);
            _is.read(isSng, 3, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["matchID"] = tars::JsonOutput::writeJson(matchID);
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["drawback"] = tars::JsonOutput::writeJson(drawback);
            p->value["isSng"] = tars::JsonOutput::writeJson(isSng);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(matchID,pObj->value["matchID"], false);
            tars::JsonInput::readJson(uid,pObj->value["uid"], false);
            tars::JsonInput::readJson(drawback,pObj->value["drawback"], false);
            tars::JsonInput::readJson(isSng,pObj->value["isSng"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(matchID,"matchID");
            _ds.display(uid,"uid");
            _ds.display(drawback,"drawback");
            _ds.display(isSng,"isSng");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(matchID, true);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(drawback, true);
            _ds.displaySimple(isSng, false);
            return _os;
        }
    public:
        tars::Int32 matchID;
        tars::Int64 uid;
        tars::Bool drawback;
        tars::Bool isSng;
    };
    inline bool operator==(const QuitReq&l, const QuitReq&r)
    {
        return l.matchID == r.matchID && l.uid == r.uid && l.drawback == r.drawback && l.isSng == r.isSng;
    }
    inline bool operator!=(const QuitReq&l, const QuitReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const QuitReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,QuitReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct QuitResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "match.QuitResp";
        }
        static string MD5()
        {
            return "e1e2e94545bd248d297d9dda23886b39";
        }
        QuitResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (resultCode != 0)
            {
                _os.write(resultCode, 0);
            }
            _os.write(entryFee, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, false);
            _is.read(entryFee, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["entryFee"] = tars::JsonOutput::writeJson(entryFee);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], false);
            tars::JsonInput::readJson(entryFee,pObj->value["entryFee"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(entryFee,"entryFee");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(entryFee, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        match::UserEntryFee entryFee;
    };
    inline bool operator==(const QuitResp&l, const QuitResp&r)
    {
        return l.resultCode == r.resultCode && l.entryFee == r.entryFee;
    }
    inline bool operator!=(const QuitResp&l, const QuitResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const QuitResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,QuitResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
